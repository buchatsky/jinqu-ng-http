export interface IJsonReviver {
    //revive(this: any, key: string, val: any): any;
    revive(that: any, key: string, val: any): any;
}

export const enum StrMatch {
    None = 0,
    Date = 1,
    DateTime = 2,
    DateTimeOffset = 4,
    All = 7
}

export class JsonDateReviver implements IJsonReviver {
    protected static DateMask = /^\d{4}-(0\d|1[0-2])-([0-2]\d|3[01])$/;
    protected static DateTimeMask = /^\d{4}-(0\d|1[0-2])-([0-2]\d|3[01])T([01]\d|2[0-3]):[0-5]\d:[0-5]\d(\.\d+)?$/;
    protected static DateTimeOffsetMask = /^\d{4}-(0\d|1[0-2])-([0-2]\d|3[01])T([01]\d|2[0-3]):[0-5]\d:[0-5]\d(\.\d+)?([+-]([01]\d|2[0-3]):[0-5]\d|Z)$/;
    protected static AllMask = /^\d{4}-(0\d|1[0-2])-([0-2]\d|3[01])(T([01]\d|2[0-3]):[0-5]\d:[0-5]\d(\.\d+)?([+-]([01]\d|2[0-3]):[0-5]\d|Z))?$/;

    constructor(protected strMatch: StrMatch) { }

    //public revive(key: string, value: any): any {
    //public revive(this: any, key: string, value: any): any {
    public revive(that: any, key: string, value: any): any {
        if (typeof value === 'string' && JsonDateReviver.matchDate(value)) {
            return new Date(value);
        } else {
            return value;
        }
    }

    protected static matchDate(value: string): boolean {
        let ret: boolean = false;
        if (this.strMatch === StrMatch.All) {
            ret = JsonDateReviver.AllMask.test(value);
        } else {
            // tslint:disable-next-line: no-bitwise
            if (!ret && this.strMatch! & StrMatch.Date) {
                ret = ret || JsonDateReviver.DateMask.test(value);
            }
            // tslint:disable-next-line: no-bitwise
            if (!ret && this.strMatch! & StrMatch.DateTimeOffset) {
                ret = ret || JsonDateReviver.DateTimeOffsetMask.test(value);
            }
            // tslint:disable-next-line: no-bitwise
            if (!ret && this.strMatch! & StrMatch.DateTime) {
                ret = ret || JsonDateReviver.DateTimeMask.test(value);
            }
        }
        return ret;
    }
}

